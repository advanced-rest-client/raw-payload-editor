<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">

    <script src="../../../@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../../@polymer/test-fixture/test-fixture.js"></script>
    <script src="../../../mocha/mocha.js"></script>
    <script src="../../../chai/chai.js"></script>
    <script src="../../../wct-mocha/wct-mocha.js"></script>

    <script src="../../../jsonlint/lib/jsonlint.js"></script>
    <script src="../../../codemirror/lib/codemirror.js"></script>
    <script src="../../../codemirror/addon/mode/loadmode.js"></script>
    <script src="../../../codemirror/mode/meta.js"></script>
    <script src="../../../codemirror/mode/javascript/javascript.js"></script>
    <script src="../../../codemirror/mode/xml/xml.js"></script>
    <script src="../../../codemirror/mode/htmlmixed/htmlmixed.js"></script>
    <script src="../../../codemirror/addon/lint/lint.js"></script>
    <script src="../../../codemirror/addon/lint/json-lint.js"></script>
  </head>
  <body>

    <test-fixture id="basic">
      <template>
        <raw-payload-editor></raw-payload-editor>
      </template>
    </test-fixture>

    <test-fixture id="encode">
      <template>
        <raw-payload-editor content-type="application/x-www-form-urlencoded"></raw-payload-editor>
      </template>
    </test-fixture>

    <script type="module">
    import '../raw-payload-editor.js';
    import {tap} from '../../../@polymer/iron-test-helpers/mock-interactions.js';
    function fire(name, detail, node) {
      const event = new CustomEvent(name, {
        bubbles: true,
        composed: true,
        detail: detail
      });
      (node || document).dispatchEvent(event);
      return event;
    }
    suite('basic', function() {
      let element;

      setup(function() {
        element = fixture('basic');
      });

      test('contentType is undefined', function() {
        assert.isUndefined(element.contentType);
      });

      test('encodeEnabled is false', function() {
        assert.isFalse(element.encodeEnabled);
      });

      test('Handling content-type-changed', function() {
        fire('content-type-changed', {
          value: 'text/plain'
        });
        assert.equal(element.contentType, 'text/plain');
      });

      test('Content type changes editor mode', function() {
        element.contentType = 'application/xml';
        assert.equal(element.shadowRoot.querySelector('code-mirror').mode, element.contentType);
      });

      test('Content type with charset changes editor mode', function() {
        element.contentType = 'application/xml; charset="utf-8"';
        assert.equal(element.shadowRoot.querySelector('code-mirror').mode, 'application/xml');
      });

      test('The encodeEnabled is true for application/x-www-form-urlencoded', function() {
        element.contentType = 'application/x-www-form-urlencoded';
        assert.isTrue(element.encodeEnabled);
      });

      test('Code Mirror value changes after value change', function() {
        element.value = 'test';
        const cm = element.shadowRoot.querySelector('code-mirror');
        assert.equal(cm.value, element.value);
      });
    });

    suite('encoder-decoder', function() {
      let element;
      const decodedValue = 'x test=x value';
      const encodedValue = 'x+test=x+value';

      setup(function() {
        element = fixture('encode');
        element.contentType = 'application/x-www-form-urlencoded';
      });

      test('Action controls are rendered', function(done) {
        flush(function() {
          const container = element.shadowRoot.querySelector('.action-buttons[data-type="form"]');
          assert.ok(container);
          done();
        });
      });

      test('Encodes parameters', function() {
        element.value = decodedValue;
        element.encodeValue();
        assert.equal(element.value, encodedValue);
      });

      test('Decodes parameters', function() {
        element.value = encodedValue;
        element.decodeValue();
        assert.equal(element.value, decodedValue);
      });
    });

    suite('JSON tranformer', function() {
      let element;
      setup(function() {
        element = fixture('encode');
        element.contentType = 'application/json';
      });

      test('Formatting controls are rendered', function(done) {
        flush(function() {
          const container = element.$$('.action-buttons[data-type="json"]');
          assert.ok(container);
          done();
        });
      });

      test('Formats JSON', function(done) {
        const initialValue = '{"a":"b"}';
        element.value = initialValue;
        flush(function() {
          const button = element.shadowRoot.querySelector('[data-action="format-json"]');
          tap(button);
          assert.typeOf(element.value, 'string');
          assert.isAbove(element.value.length, 9);
          done();
        });
      });

      test('Minifies JSON', function(done) {
        const initialValue = '{\t"a":\n"b"\n\t}';
        const finalValue = '{"a":"b"}';
        element.value = initialValue;
        flush(function() {
          const button = element.shadowRoot.querySelector('[data-action="minify-json"]');
          tap(button);
          assert.equal(element.value, finalValue);
          done();
        });
      });
    });
    </script>

  </body>
</html>
